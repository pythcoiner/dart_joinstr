// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`

ListCoinsResult listCoins({
  required String mnemonics,
  required String electrumUrl,
  required int electrumPort,
  required (int, int) range,
  required DNetwork network,
}) => RustLib.instance.api.crateApiJoinstrListCoins(
  mnemonics: mnemonics,
  electrumUrl: electrumUrl,
  electrumPort: electrumPort,
  range: range,
  network: network,
);

CoinjoinResult initiateCoinjoin({
  required DPoolConfig config,
  required DPeerConfig peer,
}) => RustLib.instance.api.crateApiJoinstrInitiateCoinjoin(
  config: config,
  peer: peer,
);

ListPoolsResult listPools({
  required BigInt back,
  required BigInt timeout,
  required String relay,
}) => RustLib.instance.api.crateApiJoinstrListPools(
  back: back,
  timeout: timeout,
  relay: relay,
);

CoinjoinResult joinCoinjoin({required DPool pool, required DPeerConfig peer}) =>
    RustLib.instance.api.crateApiJoinstrJoinCoinjoin(pool: pool, peer: peer);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DAddress>>
abstract class DAddress implements RustOpaqueInterface {
  static Future<DAddress?> fromString({required String value}) =>
      RustLib.instance.api.crateApiJoinstrDAddressFromString(value: value);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DCoin>>
abstract class DCoin implements RustOpaqueInterface {
  Future<double> amountBtc();

  Future<BigInt> amountSat();

  Future<String> outpoint();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DMnemonic>>
abstract class DMnemonic implements RustOpaqueInterface {
  static Future<DMnemonic?> fromString({required String value}) =>
      RustLib.instance.api.crateApiJoinstrDMnemonicFromString(value: value);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DPeerConfig>>
abstract class DPeerConfig implements RustOpaqueInterface {
  int get electrumPort;

  String get electrumUrl;

  DCoin get input;

  DMnemonic get mnemonics;

  DAddress get output;

  String get relay;

  set electrumPort(int electrumPort);

  set electrumUrl(String electrumUrl);

  set input(DCoin input);

  set mnemonics(DMnemonic mnemonics);

  set output(DAddress output);

  set relay(String relay);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DPool>>
abstract class DPool implements RustOpaqueInterface {
  Future<double?> denominationBtc();

  Future<BigInt?> denominationSat();

  Future<int?> fee();

  Future<BigInt?> peers();

  Future<String?> relay();
}

class CoinjoinResult {
  final String txid;
  final String error;

  const CoinjoinResult({required this.txid, required this.error});

  Future<bool> isError() =>
      RustLib.instance.api.crateApiJoinstrCoinjoinResultIsError(that: this);

  Future<bool> isOk() =>
      RustLib.instance.api.crateApiJoinstrCoinjoinResultIsOk(that: this);

  @override
  int get hashCode => txid.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CoinjoinResult &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          error == other.error;
}

enum DNetwork { regtest, signet, testnet, bitcoin }

class DPoolConfig {
  final double denomination;
  final int fee;
  final BigInt maxDuration;
  final BigInt peers;
  final DNetwork network;

  const DPoolConfig({
    required this.denomination,
    required this.fee,
    required this.maxDuration,
    required this.peers,
    required this.network,
  });

  @override
  int get hashCode =>
      denomination.hashCode ^
      fee.hashCode ^
      maxDuration.hashCode ^
      peers.hashCode ^
      network.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DPoolConfig &&
          runtimeType == other.runtimeType &&
          denomination == other.denomination &&
          fee == other.fee &&
          maxDuration == other.maxDuration &&
          peers == other.peers &&
          network == other.network;
}

class ListCoinsResult {
  final List<DCoin> coins;
  final String error;

  const ListCoinsResult({required this.coins, required this.error});

  @override
  int get hashCode => coins.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListCoinsResult &&
          runtimeType == other.runtimeType &&
          coins == other.coins &&
          error == other.error;
}

class ListPoolsResult {
  final List<DPool> pools;
  final String error;

  const ListPoolsResult({required this.pools, required this.error});

  @override
  int get hashCode => pools.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListPoolsResult &&
          runtimeType == other.runtimeType &&
          pools == other.pools &&
          error == other.error;
}
