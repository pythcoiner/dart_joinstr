// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.8.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`

ListCoinsResult listCoins({
  required String mnemonics,
  required String electrumUrl,
  required int electrumPort,
  required (int, int) range,
  required Network network,
}) => RustLib.instance.api.crateApiJoinstrListCoins(
  mnemonics: mnemonics,
  electrumUrl: electrumUrl,
  electrumPort: electrumPort,
  range: range,
  network: network,
);

CoinjoinResult initiateCoinjoin({
  required PoolConfig config,
  required PeerConfig peer,
}) => RustLib.instance.api.crateApiJoinstrInitiateCoinjoin(
  config: config,
  peer: peer,
);

ListPoolsResult listPools({
  required BigInt back,
  required BigInt timeout,
  required String relay,
}) => RustLib.instance.api.crateApiJoinstrListPools(
  back: back,
  timeout: timeout,
  relay: relay,
);

CoinjoinResult joinCoinjoin({required Pool pool, required PeerConfig peer}) =>
    RustLib.instance.api.crateApiJoinstrJoinCoinjoin(pool: pool, peer: peer);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Address>>
abstract class Address implements RustOpaqueInterface {
  static Future<Address?> fromString({required String value}) =>
      RustLib.instance.api.crateApiJoinstrAddressFromString(value: value);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Coin>>
abstract class Coin implements RustOpaqueInterface {
  double amountBtc();

  BigInt amountSat();

  String outpoint();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Mnemonic>>
abstract class Mnemonic implements RustOpaqueInterface {
  static Mnemonic? fromString({required String value}) =>
      RustLib.instance.api.crateApiJoinstrMnemonicFromString(value: value);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerConfig>>
abstract class PeerConfig implements RustOpaqueInterface {
  int get electrumPort;

  String get electrumUrl;

  Coin get input;

  Mnemonic get mnemonics;

  Address get output;

  String get relay;

  set electrumPort(int electrumPort);

  set electrumUrl(String electrumUrl);

  set input(Coin input);

  set mnemonics(Mnemonic mnemonics);

  set output(Address output);

  set relay(String relay);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Pool>>
abstract class Pool implements RustOpaqueInterface {
  double? denominationBtc();

  BigInt? denominationSat();

  int? fee();

  BigInt? peers();

  String? relay();
}

class CoinjoinResult {
  final String txid;
  final String error;

  const CoinjoinResult({required this.txid, required this.error});

  bool isError() =>
      RustLib.instance.api.crateApiJoinstrCoinjoinResultIsError(that: this);

  bool isOk() =>
      RustLib.instance.api.crateApiJoinstrCoinjoinResultIsOk(that: this);

  @override
  int get hashCode => txid.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CoinjoinResult &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          error == other.error;
}

class ListCoinsResult {
  final List<Coin> coins;
  final String error;

  const ListCoinsResult({required this.coins, required this.error});

  @override
  int get hashCode => coins.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListCoinsResult &&
          runtimeType == other.runtimeType &&
          coins == other.coins &&
          error == other.error;
}

class ListPoolsResult {
  final List<Pool> pools;
  final String error;

  const ListPoolsResult({required this.pools, required this.error});

  @override
  int get hashCode => pools.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListPoolsResult &&
          runtimeType == other.runtimeType &&
          pools == other.pools &&
          error == other.error;
}

enum Network { regtest, signet, testnet, bitcoin }

class PoolConfig {
  final double denomination;
  final int fee;
  final BigInt maxDuration;
  final BigInt peers;
  final Network network;

  const PoolConfig({
    required this.denomination,
    required this.fee,
    required this.maxDuration,
    required this.peers,
    required this.network,
  });

  @override
  int get hashCode =>
      denomination.hashCode ^
      fee.hashCode ^
      maxDuration.hashCode ^
      peers.hashCode ^
      network.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PoolConfig &&
          runtimeType == other.runtimeType &&
          denomination == other.denomination &&
          fee == other.fee &&
          maxDuration == other.maxDuration &&
          peers == other.peers &&
          network == other.network;
}
